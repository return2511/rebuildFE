# Set 类型

###  Set有哪些基础方法

JavaScript 的 `Set` 对象是一个构造函数，用于创建含有唯一值的集合。这些值可以是任何类型。`Set` 提供了以下基础方法：

1. `add(value)`: 向 `Set` 中添加一个新元素。如果该元素已经存在于 `Set` 中，则不会添加重复的元素。
2. `delete(value)`: 从 `Set` 中删除一个元素。如果该元素存在于 `Set` 中，删除它并返回 `true`；否则返回 `false`。
3. `has(value)`: 检查 `Set` 中是否存在一个指定的值。如果该值存在，返回 `true`；否则返回 `false`。
4. `clear()`: 清空 `Set` 中的所有元素。
5. `forEach(callbackFn, thisArg)`: 对 `Set` 中的每个元素执行提供的回调函数。`thisArg` 参数（可选）在回调函数中作为 `this` 的值。
6. `values()`: 返回一个新的迭代器对象，它包含 `Set` 对象中每个元素的值。
7. `keys()`: 由于 `Set` 是一组值的集合，所以 `keys()` 方法的行为与 `values()` 方法相同。
8. `entries()`: 返回一个新的迭代器对象，它包含 `[value, value]` 对，用于每个元素的值。这个方法存在是为了使 `Set` 对象与 `Map` 对象保持接口一致。

除了这些方法，`Set` 对象也支持 `size` 属性，用于获取 `Set` 中元素的数量。

### Set通常有哪些用法，用hash算法时是用普通对象还是Set

JavaScript 的 `Set` 对象通常用于存储唯一值的集合。这使得它在某些特定场景下非常有用。以下是一些常见的 `Set` 使用场景：

1. **去重**: 利用 `Set` 只能存储唯一值的特性，可以很方便地从数组中移除重复元素。

   ```javascript
   const array = [1, 2, 2, 3, 4, 4, 5];
   const uniqueArray = [...new Set(array)];
   ```
2. **值的存在性检查**: `Set` 的 `has` 方法提供了一种比数组更高效的方式来检查元素是否存在于集合中，尤其是在大型集合中。
3. **并集、交集、差集操作**: 可以利用 `Set` 进行数组或集合的并集、交集和差集运算。
4. **数据存储**: 当需要存储不重复的值时（如标签、关键词等），使用 `Set` 比数组更为适宜。
关于使用普通对象还是 `Set` 进行哈希操作的问题，这取决于具体场景：
- **使用普通对象**:
  - 当需要存储键值对时，且键是字符串或符号。
  - 当需要在哈希结构中包含额外的数据或方法。
- **使用 `Set`**:
  - 当只关心值的唯一性，不需要映射键到值。
  - 当需要高效地进行存在性检查、添加和删除操作。
  - 当利用 `Set` 提供的迭代器和方法可以简化代码。

在许多情况下，`Set` 提供了比普通对象更适合处理唯一值集合的接口和性能优势。然而，如果你的应用场景需要键值对映射或额外的灵活性，那么使用普通对象或者 `Map` 可能更为合适。

###  `Set` 如何进行数组或集合的并集、交集和差集运算
`Set` 对象可以用来进行数组或集合的并集、交集和差集运算。下面是如何使用 `Set` 来执行这些操作的示例：

#### 并集 (Union)

并集可以通过合并两个数组或集合中的所有元素来获得，然后使用 `Set` 来确保所有值都是唯一的。

```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([4, 3, 2]);

const union = new Set([...setA, ...setB]);
// union: Set {1, 2, 3, 4}
```

#### 交集 (Intersection)

交集是两个数组或集合中共同的元素。可以通过筛选一个集合中的元素，仅保留存在于另一个集合中的元素来获得。

```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([4, 3, 2]);

const intersection = new Set([...setA].filter(x => setB.has(x)));
// intersection: Set {2, 3}
```

#### 差集 (Difference)

差集是存在于一个集合但不在另一个集合中的元素。可以通过从一个集合中过滤掉存在于另一个集合中的元素来得到。

```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([4, 3, 2]);

const difference = new Set([...setA].filter(x => !setB.has(x)));
// difference: Set {1}
```

这些操作对于处理集合数据时非常有用，特别是在需要对数据进行快速去重或者查找共有/独有元素时。利用 `Set` 的特性，这些运算既高效又易于实现。

# Map 类型
### Map有哪些方法
JavaScript 的 `Map` 对象是一个键/值对的集合，其中键和值可以是任何类型。`Map` 提供了以下主要方法：
1. **set(key, value)**: 向 `Map` 中添加或更新一个键值对。如果键已经存在，则更新其对应的值。
2. **get(key)**: 返回指定键对应的值。如果键不存在于 `Map` 中，则返回 `undefined`。
3. **has(key)**: 返回一个布尔值，表示 `Map` 中是否包含指定的键。
4. **delete(key)**: 删除 `Map` 中指定的键值对。如果键存在并且成功删除，则返回 `true`；如果键不存在，则返回 `false`。
5. **clear()**: 移除 `Map` 中的所有键/值对。
6. **keys()**: 返回一个迭代器对象，包含 `Map` 中每个元素的键。
7. **values()**: 返回一个迭代器对象，包含 `Map` 中每个元素的值。
8. **entries()**: 返回一个新的迭代器对象，它按插入顺序包含了 `Map` 中每个元素的 `[key, value]` 数组。
9. **forEach(callbackFn, thisArg)**: 按插入顺序，为 `Map` 中的每个键值对调用一次提供的回调函数。可选的 `thisArg` 参数用于回调函数中的 `this` 值。
此外，`Map` 对象还具有一个 `size` 属性，用于返回 `Map` 中键值对的数量。使用 `Map` 而不是普通对象的一个主要原因是 `Map` 保留了键值对的插入顺序，并且可以有任意类型的键。

### Map vs 普通对象的区别
`Map` 对象和普通对象（在 JavaScript 中通常指使用 `{}` 创建的对象）在多个方面有着显著的区别：

#### 键的类型

- **普通对象**: 键必须是字符串或符号（Symbols）。如果你尝试使用其他类型作为键，它会被转换成字符串。
- **Map**: 可以使用任何类型作为键，包括对象、函数、任意基本类型。

#### 键的顺序

- **普通对象**: 在 ES6 之前，对象的键没有特定的顺序。ES6 定义了一种迭代顺序，但这主要是针对字符串键，不适用于符号键。
- **Map**: 键值对在 `Map` 中是有序的。它们按照插入的顺序进行存储和迭代。

#### 性能

- **普通对象**: 对于小型或中等规模的键/值对集合，性能表现良好。但是当涉及到频繁的添加和删除操作时，其性能可能不如 `Map`。
- **Map**: 在频繁添加和删除键值对的场景下，通常提供更好的性能。尤其是在键值对数量很大时，`Map` 在查找键值对方面表现出更高的效率。

#### Size 属性

- **普通对象**: 没有内建的方法来直接获取对象的大小（即键的数量）。
- **Map**: 有一个 `size` 属性，可以直接获取键值对的数量。

#### 迭代

- **普通对象**: 需要使用 `for...in` 循环和 `Object` 类的方法如 `Object.keys()` 或 `Object.entries()` 来迭代。
- **Map**: 直接支持迭代，可以使用 `for...of` 循环，也有 `keys()`, `values()`, 和 `entries()` 方法。

#### 函数作用域

- **普通对象**: 当在对象上定义函数时，函数内的 `this` 将引用该对象。
- **Map**: `Map` 的 `forEach` 方法可以接受第二个参数，用来绑定回调函数内部的 `this` 值。

#### 序列化

- **普通对象**: 可以很容易地通过 `JSON.stringify` 进行序列化和通过 `JSON.parse` 进行反序列化。
- **Map**: 不可以直接使用 `JSON.stringify`。如果需要序列化，你需要将 `Map` 转换为数组或其他格式。

#### 用例

- **普通对象**: 更适用于当你有简单的键值对集合，且键都是字符串或符号时。
- **Map**: 更适合需要复杂键、保持插入顺序、频繁增删键值对的情况。

综上所述，选择使用 `Map` 还是普通对象取决于你的具体需求，尤其考虑到键的类型、键值对的数量、以及性能要求。

### Map 有哪些常用的场景

JavaScript 中的 `Map` 对象由于其独特的特性和灵活性，在多种编程场景中非常有用。以下是一些常见的使用 `Map` 的场景：

1. **维护键值对的有序性**:
   - 当需要保持键值对的插入顺序时，`Map` 优于普通对象。这对于某些算法和数据处理非常重要。

2. **使用非字符串键**:
   - 当你需要使用对象、函数或其他非字符串类型作为键时，`Map` 是理想的选择。

3. **高效的增删查操作**:
   - 对于涉及频繁增加、删除或查找键值对的场景，`Map` 通常提供比普通对象更高效的操作。

4. **计数和分组**:
   - `Map` 可用于计数（例如，统计字符出现次数）或对数据进行分类和分组。

5. **缓存/记忆化**:
   - `Map` 可以作为缓存结构，用于存储预先计算的结果，提高代码的执行效率，特别是在递归或重复计算昂贵的函数结果时。

6. **数据关联和映射**:
   - 当需要构建一个数据结构，将一些键（可以是任何类型）映射到特定的值时，`Map` 是一个很好的选择。

7. **实现多维数据结构**:
   - `Map` 可以嵌套使用，支持构建复杂的数据结构，如树或图。

8. **替代 switch 语句**:
   - 在某些情况下，使用 `Map` 可以替代长长的 `switch` 或一系列的 `if-else` 语句，使代码更加简洁和易于维护。

9. **权限管理**:
   - `Map` 可用于存储和管理用户权限或角色与功能之间的映射。

10. **国际化和本地化**:
    - 在国际化（i18n）应用中，`Map` 可用于存储不同语言的翻译字符串。

选择使用 `Map` 的关键在于其对任意类型键的支持、键值对的保序性，以及在频繁增删操作中的高效表现。这些特性使得 `Map` 成为处理复杂数据集时的一个强大工具。

